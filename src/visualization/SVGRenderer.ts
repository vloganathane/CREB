/**
 * SVG Molecular Structure Renderer
 * Vector-based 2D molecular structure export
 */

import { Point2D, Atom2D, Bond2D, Molecule2D } from './Canvas2DRenderer';

export interface SVGConfig {
  width: number;
  height: number;
  backgroundColor: string;
  atomColors: Record<string, string>;
  bondColor: string;
  bondWidth: number;
  fontSize: number;
  atomRadius: number;
  includeStyles: boolean;
  includeInteractivity: boolean;
}

export interface SVGExportOptions {
  format: 'svg' | 'svg-inline' | 'svg-download';
  filename?: string;
  includeMetadata?: boolean;
  optimizeSize?: boolean;
  interactive?: boolean;
  animations?: boolean;
}

/**
 * SVG-based molecular structure renderer
 */
export class SVGRenderer {
  private config: SVGConfig;
  private molecule: Molecule2D | null = null;
  private scale = 1;
  private offset = { x: 0, y: 0 };

  constructor(config: Partial<SVGConfig> = {}) {
    this.config = {
      width: 600,
      height: 400,
      backgroundColor: '#ffffff',
      atomColors: {
        'H': '#ffffff',
        'C': '#303030',
        'N': '#3050f8',
        'O': '#ff0d0d',
        'F': '#90e050',
        'P': '#ff8000',
        'S': '#ffff30',
        'Cl': '#1ff01f',
        'Br': '#a62929',
        'I': '#940094'
      },
      bondColor: '#000000',
      bondWidth: 2,
      fontSize: 14,
      atomRadius: 20,
      includeStyles: true,
      includeInteractivity: false,
      ...config
    };
  }

  /**
   * Load a molecule for rendering
   */
  loadMolecule(molecule: Molecule2D): void {
    this.molecule = molecule;
    this.centerMolecule();
  }

  /**
   * Center the molecule in the SVG viewport
   */
  private centerMolecule(): void {
    if (!this.molecule || this.molecule.atoms.length === 0) return;

    // Calculate bounding box
    let minX = Infinity, maxX = -Infinity;
    let minY = Infinity, maxY = -Infinity;

    this.molecule.atoms.forEach(atom => {
      minX = Math.min(minX, atom.position.x);
      maxX = Math.max(maxX, atom.position.x);
      minY = Math.min(minY, atom.position.y);
      maxY = Math.max(maxY, atom.position.y);
    });

    // Calculate center offset
    const molWidth = maxX - minX;
    const molHeight = maxY - minY;
    const molCenterX = (minX + maxX) / 2;
    const molCenterY = (minY + maxY) / 2;

    // Calculate scale to fit molecule
    const scaleX = (this.config.width * 0.8) / molWidth;
    const scaleY = (this.config.height * 0.8) / molHeight;
    this.scale = Math.min(scaleX, scaleY, 1);

    // Center the molecule
    this.offset.x = this.config.width / 2 - molCenterX * this.scale;
    this.offset.y = this.config.height / 2 - molCenterY * this.scale;
  }

  /**
   * Transform point from molecule coordinates to SVG coordinates
   */
  private transformPoint(point: Point2D): Point2D {
    return {
      x: point.x * this.scale + this.offset.x,
      y: point.y * this.scale + this.offset.y
    };
  }

  /**
   * Generate SVG string for the current molecule
   */
  exportSVG(options: Partial<SVGExportOptions> = {}): string {
    const opts: SVGExportOptions = {
      format: 'svg',
      includeMetadata: true,
      optimizeSize: false,
      interactive: this.config.includeInteractivity,
      animations: false,
      ...options
    };

    if (!this.molecule) {
      return this.generateEmptySVG(opts);
    }

    const svgElements: string[] = [];
    
    // SVG header
    svgElements.push(this.generateSVGHeader(opts));
    
    // Styles
    if (this.config.includeStyles) {
      svgElements.push(this.generateStyles(opts));
    }
    
    // Background
    svgElements.push(this.generateBackground());
    
    // Molecular structure
    svgElements.push(this.generateBonds(opts));
    svgElements.push(this.generateAtoms(opts));
    
    // Metadata
    if (opts.includeMetadata) {
      svgElements.push(this.generateMetadata());
    }
    
    // SVG footer
    svgElements.push('</svg>');
    
    return svgElements.join('\n');
  }

  /**
   * Generate SVG header with viewBox and namespaces
   */
  private generateSVGHeader(options: SVGExportOptions): string {
    const { width, height } = this.config;
    
    let header = `<svg width="${width}" height="${height}" viewBox="0 0 ${width} ${height}"`;
    header += ` xmlns="http://www.w3.org/2000/svg"`;
    
    if (options.interactive) {
      header += ` xmlns:xlink="http://www.w3.org/1999/xlink"`;
    }
    
    header += `>`;
    
    if (options.includeMetadata) {
      header += `\n<title>Molecular Structure - ${this.molecule?.atoms.length || 0} atoms</title>`;
      header += `\n<desc>Generated by CREB-JS Molecular Visualization System</desc>`;
    }
    
    return header;
  }

  /**
   * Generate CSS styles for the SVG
   */
  private generateStyles(options: SVGExportOptions): string {
    let styles = '<defs><style type="text/css">\n';
    
    // Base styles
    styles += `  .atom-circle { stroke: #000; stroke-width: 1; }\n`;
    styles += `  .atom-label { font-family: Arial, sans-serif; font-size: ${this.config.fontSize}px; text-anchor: middle; dominant-baseline: central; }\n`;
    styles += `  .bond-line { stroke: ${this.config.bondColor}; stroke-width: ${this.config.bondWidth}; stroke-linecap: round; }\n`;
    styles += `  .bond-double { stroke-dasharray: none; }\n`;
    styles += `  .bond-triple { stroke-width: ${this.config.bondWidth + 1}; }\n`;
    
    // Interactive styles
    if (options.interactive) {
      styles += `  .atom-group:hover .atom-circle { stroke-width: 2; stroke: #ff6b35; }\n`;
      styles += `  .atom-group:hover .atom-label { font-weight: bold; }\n`;
      styles += `  .bond-line:hover { stroke: #ff6b35; stroke-width: ${this.config.bondWidth + 1}; }\n`;
      styles += `  .atom-group { cursor: pointer; }\n`;
    }
    
    // Animation styles
    if (options.animations) {
      styles += `  @keyframes atomPulse { 0%, 100% { r: ${this.config.atomRadius}; } 50% { r: ${this.config.atomRadius + 3}; } }\n`;
      styles += `  .atom-circle:hover { animation: atomPulse 1s infinite; }\n`;
    }
    
    styles += '</style></defs>\n';
    return styles;
  }

  /**
   * Generate background rectangle
   */
  private generateBackground(): string {
    return `<rect width="100%" height="100%" fill="${this.config.backgroundColor}"/>`;
  }

  /**
   * Generate SVG elements for bonds
   */
  private generateBonds(options: SVGExportOptions): string {
    if (!this.molecule) return '';
    
    const bonds: string[] = [];
    bonds.push('<g id="bonds">');
    
    this.molecule.bonds.forEach((bond, index) => {
      const atom1 = this.molecule!.atoms[bond.atom1];
      const atom2 = this.molecule!.atoms[bond.atom2];
      
      const pos1 = this.transformPoint(atom1.position);
      const pos2 = this.transformPoint(atom2.position);
      
      bonds.push(this.generateBondSVG(pos1, pos2, bond, index, options));
    });
    
    bonds.push('</g>');
    return bonds.join('\n');
  }

  /**
   * Generate SVG for a single bond
   */
  private generateBondSVG(pos1: Point2D, pos2: Point2D, bond: Bond2D, index: number, options: SVGExportOptions): string {
    const bondClass = `bond-${bond.type || 'single'}`;
    let bondElement = '';
    
    if (bond.order === 1 || !bond.order) {
      // Single bond
      bondElement = `<line x1="${pos1.x.toFixed(2)}" y1="${pos1.y.toFixed(2)}" x2="${pos2.x.toFixed(2)}" y2="${pos2.y.toFixed(2)}" class="bond-line ${bondClass}"`;
    } else if (bond.order === 2) {
      // Double bond - two parallel lines
      const dx = pos2.x - pos1.x;
      const dy = pos2.y - pos1.y;
      const length = Math.sqrt(dx * dx + dy * dy);
      const offsetX = (-dy / length) * 3;
      const offsetY = (dx / length) * 3;
      
      bondElement = `<g class="bond-double">
        <line x1="${(pos1.x + offsetX).toFixed(2)}" y1="${(pos1.y + offsetY).toFixed(2)}" x2="${(pos2.x + offsetX).toFixed(2)}" y2="${(pos2.y + offsetY).toFixed(2)}" class="bond-line"/>
        <line x1="${(pos1.x - offsetX).toFixed(2)}" y1="${(pos1.y - offsetY).toFixed(2)}" x2="${(pos2.x - offsetX).toFixed(2)}" y2="${(pos2.y - offsetY).toFixed(2)}" class="bond-line"/>
      </g>`;
    } else if (bond.order === 3) {
      // Triple bond - three parallel lines
      const dx = pos2.x - pos1.x;
      const dy = pos2.y - pos1.y;
      const length = Math.sqrt(dx * dx + dy * dy);
      const offsetX = (-dy / length) * 3;
      const offsetY = (dx / length) * 3;
      
      bondElement = `<g class="bond-triple">
        <line x1="${pos1.x.toFixed(2)}" y1="${pos1.y.toFixed(2)}" x2="${pos2.x.toFixed(2)}" y2="${pos2.y.toFixed(2)}" class="bond-line"/>
        <line x1="${(pos1.x + offsetX).toFixed(2)}" y1="${(pos1.y + offsetY).toFixed(2)}" x2="${(pos2.x + offsetX).toFixed(2)}" y2="${(pos2.y + offsetY).toFixed(2)}" class="bond-line"/>
        <line x1="${(pos1.x - offsetX).toFixed(2)}" y1="${(pos1.y - offsetY).toFixed(2)}" x2="${(pos2.x - offsetX).toFixed(2)}" y2="${(pos2.y - offsetY).toFixed(2)}" class="bond-line"/>
      </g>`;
    }
    
    if (options.interactive) {
      bondElement += ` data-bond-id="${index}" data-atoms="${bond.atom1},${bond.atom2}"`;
    }
    
    if (bondElement.includes('<g')) {
      return bondElement;
    } else {
      return bondElement + '/>';
    }
  }

  /**
   * Generate SVG elements for atoms
   */
  private generateAtoms(options: SVGExportOptions): string {
    if (!this.molecule) return '';
    
    const atoms: string[] = [];
    atoms.push('<g id="atoms">');
    
    this.molecule.atoms.forEach((atom, index) => {
      atoms.push(this.generateAtomSVG(atom, index, options));
    });
    
    atoms.push('</g>');
    return atoms.join('\n');
  }

  /**
   * Generate SVG for a single atom
   */
  private generateAtomSVG(atom: Atom2D, index: number, options: SVGExportOptions): string {
    const pos = this.transformPoint(atom.position);
    const color = this.config.atomColors[atom.element] || '#cccccc';
    const radius = this.config.atomRadius * this.scale;
    
    let atomGroup = `<g class="atom-group" data-element="${atom.element}" data-atom-id="${index}">`;
    
    // Atom circle
    atomGroup += `<circle cx="${pos.x.toFixed(2)}" cy="${pos.y.toFixed(2)}" r="${radius.toFixed(2)}" fill="${color}" class="atom-circle"/>`;
    
    // Atom label
    const textColor = this.getContrastingColor(color);
    atomGroup += `<text x="${pos.x.toFixed(2)}" y="${pos.y.toFixed(2)}" fill="${textColor}" class="atom-label">${atom.element}</text>`;
    
    // Interactive elements
    if (options.interactive) {
      atomGroup += `<title>${atom.element} - Atom ${index + 1}</title>`;
    }
    
    atomGroup += '</g>';
    
    return atomGroup;
  }

  /**
   * Generate metadata section
   */
  private generateMetadata(): string {
    if (!this.molecule) return '';
    
    const metadata = [
      '<metadata>',
      `  <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:creb="https://creb.dev/ns#">`,
      `    <rdf:Description rdf:about="">`,
      `      <creb:atomCount>${this.molecule.atoms.length}</creb:atomCount>`,
      `      <creb:bondCount>${this.molecule.bonds.length}</creb:bondCount>`,
      `      <creb:generator>CREB-JS v${process.env.npm_package_version || '1.6.0'}</creb:generator>`,
      `      <creb:timestamp>${new Date().toISOString()}</creb:timestamp>`,
      `    </rdf:Description>`,
      `  </rdf:RDF>`,
      '</metadata>'
    ];
    
    return metadata.join('\n');
  }

  /**
   * Generate empty SVG for when no molecule is loaded
   */
  private generateEmptySVG(options: SVGExportOptions): string {
    const { width, height } = this.config;
    
    let svg = `<svg width="${width}" height="${height}" viewBox="0 0 ${width} ${height}" xmlns="http://www.w3.org/2000/svg">`;
    svg += `<rect width="100%" height="100%" fill="${this.config.backgroundColor}"/>`;
    svg += `<text x="${width/2}" y="${height/2 - 20}" text-anchor="middle" font-family="Arial" font-size="24" fill="#999">2D Molecular Structure</text>`;
    svg += `<text x="${width/2}" y="${height/2 + 20}" text-anchor="middle" font-family="Arial" font-size="14" fill="#999">Load a molecule to visualize</text>`;
    svg += '</svg>';
    
    return svg;
  }

  /**
   * Get contrasting color for text
   */
  private getContrastingColor(backgroundColor: string): string {
    // Simple contrast calculation
    const hex = backgroundColor.replace('#', '');
    const r = parseInt(hex.substr(0, 2), 16);
    const g = parseInt(hex.substr(2, 2), 16);
    const b = parseInt(hex.substr(4, 2), 16);
    const brightness = (r * 299 + g * 587 + b * 114) / 1000;
    
    return brightness > 128 ? '#000000' : '#ffffff';
  }

  /**
   * Export as downloadable SVG file
   */
  exportAsFile(filename: string = 'molecule.svg', options: Partial<SVGExportOptions> = {}): void {
    const svgContent = this.exportSVG({ ...options, format: 'svg-download' });
    
    // Create download link (browser only)
    if (typeof document !== 'undefined') {
      const blob = new Blob([svgContent], { type: 'image/svg+xml' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = filename;
      link.click();
      URL.revokeObjectURL(url);
    } else {
      // Node.js environment - would need fs module
      console.log('SVG content:', svgContent);
    }
  }

  /**
   * Get current molecule data
   */
  getMolecule(): Molecule2D | null {
    return this.molecule;
  }

  /**
   * Update configuration
   */
  updateConfig(config: Partial<SVGConfig>): void {
    this.config = { ...this.config, ...config };
    this.centerMolecule();
  }
}

export default SVGRenderer;
